<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Media Viewer</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='show_style.css') }}">
  <script>
    // server-injected prefetch (may be "null")
    window.INITIAL_MEDIA = {{ INITIAL_MEDIA|safe }};
    window.SERVER_USER = {{ SERVER_USER|safe }};
    // concise objects for easier access in client code
    window.LOGGED = {{ SERVER_LOGGED|safe }};
    window.PUBLISHER = {{ SERVER_PUBLISHER|safe }};
    window.COMMENTER = {{ SERVER_COMMENTER|safe }};
  </script>
</head>
<body>
  <div class="media-container">
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px;">
      <a href="{{ url_for('home.homepage', form_type='feed') }}" id="back-to-feed" class="nav-item button-like">Torna al Feed</a>

      <h1 id="media-title">Caricamento...</h1>
      <div id="admin-actions" style="margin-left:auto;display:flex;gap:8px;"></div>
    </div>

    <div id="media-uploader" style="margin-bottom:8px;color:var(--muted)"></div>

    <div id="media-display" class="media-display">
      <div id="video-box" class="hidden">
        <video id="video-player" controls><source id="video-source"></video>
      </div>
      <div id="audio-box" class="hidden">
        <audio id="audio-player" controls><source id="audio-source"></source></audio>
      </div>
      <div id="document-box" class="hidden">
        <iframe id="document-viewer" src="" frameborder="0"></iframe>
      </div>
      <div id="concert-box" class="hidden">
        <iframe id="concert-iframe" src="" frameborder="0" allowfullscreen></iframe>
        <div id="concert-subtracks"></div>
      </div>
    </div>

    <div id="media-details-content"></div>

    <div id="open-with-area" style="margin-top:12px">
      <strong>Apri con:</strong>
      <div id="open-with-buttons" style="margin-top:8px"></div>
    </div>

    <!-- EDIT FORM (hidden) -->
    <div id="modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div id="editForm" class="form-modal" role="dialog" aria-modal="true" aria-labelledby="edit-title-h">
      <div class="modal-panel">
        <h3 id="edit-title-h">Edit metadata</h3>
        <div class="modal-grid">
          <label>Title<br><input id="edit-title" style="width:100%"></label>
          <label>Year<br><input id="edit-year" type="number" style="width:100%"></label>
          <label>Duration (sec)<br><input id="edit-duration" type="number" style="width:100%"></label>
          <label>Recording date<br><input id="edit-recording-date" type="date" style="width:100%"></label>
          <label>Recording location<br><input id="edit-recording-location" style="width:100%"></label>
          <label>Location (stored_at)<br><input id="edit-stored-at" style="width:100%"></label>
          <label>Link<br><input id="edit-link" style="width:100%"></label>
          <label>Format / File format<br><input id="edit-format" style="width:100%"></label>
          <label>Pages (document)<br><input id="edit-pages" type="number" style="width:100%"></label>
          <label>Is author<br><input id="edit-is-author" type="checkbox"></label>
          <label>Is performer<br><input id="edit-is-performer" type="checkbox"></label>
          <label>Genres (comma separated)<br><input id="edit-genres" style="width:100%"></label>
          <label>Authors (comma separated)<br><input id="edit-authors" style="width:100%"></label>
          <label>Performers (comma separated)<br><input id="edit-performers" style="width:100%"></label>
        </div>
        <div style="margin-top:8px">
          <label>Description<br><textarea id="edit-description" style="width:100%;height:120px"></textarea></label>
        </div>
        <div class="modal-actions">
          <button id="edit-cancel" type="button">Cancel</button>
          <button id="edit-save" type="button" style="margin-left:8px">Save</button>
        </div>
      </div>
    </div>

    <!-- DELETE CONFIRM -->
    <div id="confirmationDialog" class="form-modal confirmation" role="dialog" aria-modal="true" aria-labelledby="confirm-h">
      <div class="modal-panel">
        <h3 id="confirm-h" style="margin-top:0;color:#ff2770">Confirm deletion</h3>
        <div>Sei sicuro di voler eliminare questo media?</div>
        <div class="modal-actions">
          <button id="confirmCancel">Cancel</button>
          <button id="confirmDelete" style="margin-left:8px">Delete</button>
        </div>
      </div>
    </div>

    <!-- COMMENTS -->
    <div class="comments-area" id="comments-area" style="margin-top:20px">
      <h2>Commenti</h2>
      <div id="comments-list">Caricamento commenti...</div>

      <!-- reply context (hidden until user clicks "Rispondi") -->
      <div id="reply-context" style="display:none;margin-top:8px;color:var(--muted);align-items:center;gap:8px;">
        Rispondi a: <strong id="reply-to-name" style="margin-left:6px"></strong>
        <button id="reply-cancel" style="margin-left:12px">Annulla</button>
      </div>

      <!-- hidden field that always stores selected parent comment id -->
      <input type="hidden" id="parent-comment-id" value="">

      <div class="comment-input" style="margin-top:12px">
        <textarea id="comment-text" placeholder="Scrivi un commento..."></textarea>
        <button id="comment-send">Invia</button>
      </div>
    </div>
  </div>

<script>
(async function(){
  function showModal(id, show = true){
    const el = document.getElementById(id);
    const backdrop = document.getElementById('modal-backdrop');
    if(!el) return;
    if(show){
      el.classList.add('open');
      if(backdrop) backdrop.style.display = 'block';
      el.setAttribute('aria-hidden', 'false');
    } else {
      el.classList.remove('open');
      if(backdrop) backdrop.style.display = 'none';
      el.setAttribute('aria-hidden', 'true');
    }
  }

  const qs = name => new URLSearchParams(window.location.search).get(name);
  const mediaId = qs('media_id');
  if(!mediaId){ document.getElementById('media-title').textContent = "Media non trovato"; return; }
  const el = id => document.getElementById(id);

  // reply context: active reply target id (string) and utility
  let replyToCommentId = null;
  const clearReply = () => {
    replyToCommentId = null;
    const ctx = el('reply-context');
    if (ctx) ctx.style.display = 'none';
    const name = el('reply-to-name');
    if (name) name.textContent = '';
    const hidden = el('parent-comment-id');
    if (hidden) hidden.value = '';
  };
  // reply cancel button (register once)
  document.addEventListener('click', (ev) => {
    if (ev.target && ev.target.id === 'reply-cancel') { clearReply(); }
  });

  // ---------- HELPERS ----------
  const formatTime = s => {
    s = Number(s) || 0;
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60);
    return `${m}:${sec.toString().padStart(2,'0')}`;
  };

  // Format comment timestamps into '30th dec. 2025 04:05'
  const formatTimestamp = iso => {
    if(!iso) return '';
    try {
      const d = new Date(String(iso));
      if (isNaN(d)) return String(iso);
      const day = d.getDate();
      const getSuffix = (n) => {
        if (n % 100 >= 11 && n % 100 <= 13) return 'th';
        switch (n % 10) {
          case 1: return 'st';
          case 2: return 'nd';
          case 3: return 'rd';
          default: return 'th';
        }
      };
      const months = ['jan.','feb.','mar.','apr.','may.','jun.','jul.','aug.','sep.','oct.','nov.','dec.'];
      const suffix = getSuffix(day);
      const mon = months[d.getMonth()] || '';
      const year = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${day}${suffix} ${mon} ${year} ${hh}:${mm}`;
    } catch (e) {
      return String(iso);
    }
  };

  // --------- Permissions helpers (use server-injected objects) ---------
  const LOGGED = window.LOGGED || window.SERVER_USER || null;
  const SERVER_PUBLISHER = window.PUBLISHER || null;
  const canComment = () => {
    if(!LOGGED || LOGGED.lvl === undefined || LOGGED.lvl === null) return false;
    const lvl = Number(LOGGED.lvl);
    return ![5,6].includes(lvl);
  };
  const canReply = () => canComment();
  const canEditAny = () => {
    if(!LOGGED || LOGGED.lvl === undefined || LOGGED.lvl === null) return false;
    return Number(LOGGED.lvl) < 3;
  };
  const canDeleteAny = () => {
    if(!LOGGED) return false;
    if(canEditAny()) return true;
    const loggedId = LOGGED.id !== undefined && LOGGED.id !== null ? String(LOGGED.id) : null;
    const pubId = SERVER_PUBLISHER && SERVER_PUBLISHER.id ? String(SERVER_PUBLISHER.id) : null;
    return (loggedId && pubId && loggedId === pubId);
  };

  const extractYouTubeId = url => {
    if(!url) return null;
    const m = url.match(/(?:v=|\/embed\/|youtu\.be\/)([A-Za-z0-9_-]{6,})/);
    return m ? m[1] : null;
  };

  const safeJoin = (arr, fallback='-') => {
    if(!arr) return fallback;
    if(Array.isArray(arr) && arr.length){
      const mapped = arr.map(a => {
        if(!a) return '';
        if(typeof a === 'string' || typeof a === 'number') return String(a);
        if(a.name) return a.name;
        if(a.username) return a.username;
        if(a.performer) return a.performer;
        return JSON.stringify(a);
      }).filter(Boolean);
      return mapped.length ? mapped.join(', ') : fallback;
    }
    return fallback;
  };

  // ---------- COMMENTS ----------
  async function loadComments(){
    try {
      console.debug('[comments] loadComments start for media_id=', mediaId);
      const res = await fetch(`/show/comments?media_id=${encodeURIComponent(mediaId)}`);
      console.debug('[comments] fetch completed, response status=', res.status, 'ok=', res.ok);
      if(!res.ok) throw new Error('Fetch error');
      let arr = await res.json();
      console.debug('[comments] raw json payload received:', arr);

      // normalize many possible server shapes into an array of comments
      if(!arr) arr = [];
      if(!Array.isArray(arr)){
        if (Array.isArray(arr.results)) arr = arr.results;
        else if (Array.isArray(arr.response)) arr = arr.response;
        else if (Array.isArray(arr.comments)) arr = arr.comments;
        else if (arr && typeof arr === 'object' && Object.keys(arr).length && (arr.comment || arr.item)) {
          const single = arr.comment || arr.item;
          arr = Array.isArray(single) ? single : [single];
        } else {
          // unknown shape -> empty
          arr = [];
        }
      }
      console.debug('[comments] normalized array length=', arr.length);

      const list = el('comments-list');
      list.innerHTML = '';
      if(!arr.length){ list.textContent = 'Nessun commento'; return; }
      console.debug('[comments] rendering', arr.length, 'comments');

      const extractAuthor = (c) => {
        // canonical: return { username, display_name, avatar, id, lvl }
        if(!c) return { username: null, display_name: 'Anonimo', avatar: null, id: null, lvl: null };
        // server will often send username / display_name / avatar
        const avatarKeys = ['avatar','avatar_url','profile_pic','picture','image','photo','gravatar','profile_image'];
        let username = (typeof c.username === 'string' ? c.username : null);
        if(!username && c.user && typeof c.user === 'object' && typeof c.user.username === 'string') username = c.user.username;
        if(!username && typeof c.author_username === 'string') username = c.author_username;
        if(!username && typeof c.author === 'string') username = c.author;

        let display_name = c.display_name || c.author || c.name || (username || null) || 'Anonimo';

        let avatar = c.avatar || null;
        if(!avatar && c.user && typeof c.user === 'object'){
          avatar = c.user.avatar || c.user.avatar_url || c.user.picture || c.user.profile_image || null;
        }
        for (const k of avatarKeys) {
          if (!avatar && c[k]) { avatar = c[k]; break; }
        }

        // commenter's user id
        let commenterId = null;
        if (c.user && typeof c.user === 'object' && (c.user.id || c.user.user_id)) commenterId = c.user.id || c.user.user_id;
        if (!commenterId && (c.user_id || c.author_id)) commenterId = c.user_id || c.author_id;

        // commenter level if available (may be numeric or string)
        let lvl = null;
        if (c.user && typeof c.user === 'object' && (c.user.lvl !== undefined || c.user.level !== undefined)){
          lvl = c.user.lvl !== undefined ? c.user.lvl : c.user.level;
        } else if (c.lvl !== undefined || c.level !== undefined) {
          lvl = c.lvl !== undefined ? c.lvl : c.level;
        }
        if (lvl !== null) {
          try { lvl = Number(lvl); } catch(e) { /* leave as-is */ }
        }

        // Normalize avatar filenames/urls:
        // - if it's an absolute URL or starts with '/', leave it
        // - otherwise treat as stored profile filename and proxy via /profile/picture/<name>
        if (avatar && typeof avatar === 'string') {
          const a = avatar.trim();
          if (!/^([a-z]+:)?\/\//i.test(a) && !a.startsWith('/')) {
            avatar = `/profile/picture/${encodeURIComponent(a)}`;
          } else {
            avatar = a;
          }
        }

        return { username: username || null, display_name: display_name, avatar: avatar || null, id: commenterId || null, lvl: lvl };
      };

      // Build canonical nodes
      const getId = c => c.id || c.comment_id || c._id || c.commentId || null;
      const getParentId = c => {
        if (!c) return null;
        // direct scalar parent ids
        if (c.parent_comment_id && typeof c.parent_comment_id !== 'object') return c.parent_comment_id;
        if (c.parent && typeof c.parent !== 'object') return c.parent;
        // handle nested parent objects: parent_comment / parent_comment_id / parent
        const parentObj = c.parent_comment || c.parent_comment_id || c.parent || c.parentComment || c.parent_comment_object;
        if (parentObj && typeof parentObj === 'object') {
          if ('id' in parentObj) return parentObj.id;
          if ('comment_id' in parentObj) return parentObj.comment_id;
        }
        if (c.reply_to) return c.reply_to;
        if (c.parentCommentId) return c.parentCommentId;
        return null;
      };
      const nodes = [];
      const map = {};
      // reply state is handled at outer scope (see clearReply defined above)
      
      arr.forEach(c=>{
        const id = getId(c);
        if(!id) return; // skip invalid
        const parent = getParentId(c);
        const who = extractAuthor(c);
        const node = {
          id: String(id),
          parent_id: parent ? String(parent) : null,
          username: who.username || null,
          display_name: who.display_name || 'Anonimo',
          avatar: who.avatar || null,
          commenter_id: who.id || null,
          commenter_lvl: who.lvl !== undefined ? who.lvl : null,
          when: c.created_at || c.date || c.createdAt || '',
          text: c.text || c.content || c.body || '',
          raw: c,
          children: []
        };
        nodes.push(node);
        map[node.id] = node;
      });

      // attach children
      const roots = [];
      nodes.forEach(n=>{
        if(n.parent_id && map[n.parent_id]){
          map[n.parent_id].children.push(n);
          n._parent = map[n.parent_id];
        } else {
          roots.push(n);
        }
      });

      // recursive renderer
      // count descendants (replies to replies) for collapse decisions
      const countDescendants = (node) => {
        if(!node || !node.children || !node.children.length) return 0;
        let cnt = node.children.length;
        node.children.forEach(c => { cnt += countDescendants(c); });
        return cnt;
      };

      const renderNode = (node) => {
        const div = document.createElement('div');
        div.className = 'comment';
        div.id = `comment-${node.id}`;
        // header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        if (node.avatar) {
          const img = document.createElement('img');
          img.src = node.avatar;
          img.alt = node.username || node.display_name || 'avatar';
          img.style.width = '32px';
          img.style.height = '32px';
          img.style.borderRadius = '50%';
          img.style.marginRight = '8px';
          img.style.objectFit = 'cover';
          header.appendChild(img);
        }
        const whoLink = document.createElement('a');
        // display name shown always, profile link only if we have a real username
        if (node.username) {
          whoLink.href = `/home/?form_type=profile&username=${encodeURIComponent(node.username)}`;
          whoLink.target = '_blank';
          whoLink.style.color = 'var(--accent-2)';
          whoLink.style.textDecoration = 'none';
        } else {
          whoLink.href = 'javascript:void(0)';
          whoLink.style.color = 'var(--muted)';
          whoLink.style.textDecoration = 'none';
        }
        whoLink.textContent = node.display_name;
        header.appendChild(whoLink);

        // small timestamp + optional parent link (showing only clickable parent username)
        const meta = document.createElement('div');
        meta.style.marginLeft = '8px';
        const small = document.createElement('small'); small.style.color = 'var(--muted)'; small.textContent = formatTimestamp(node.when);
        meta.appendChild(small);
        if(node.parent_id && map[node.parent_id]){
          const parent = map[node.parent_id];
          const inrep = document.createElement('span');
          inrep.style.marginLeft = '8px';
          inrep.style.color = 'var(--muted)';
          // if parent has a profile username, link to it; otherwise just reference display name
          if (parent.username) {
            inrep.innerHTML = `in reply to <a href="#comment-${parent.id}" style="color:var(--accent-2);text-decoration:none">@${parent.username}</a>`;
          } else {
            inrep.innerHTML = `in reply to <span style="color:var(--muted)">@${parent.display_name}</span>`;
          }
          meta.appendChild(inrep);
        }
        header.appendChild(meta);

        // body
        const body = document.createElement('div'); body.style.marginTop = '6px'; body.textContent = node.text;

        // actions
        const actions = document.createElement('div'); actions.style.marginTop='6px';

        // determine permissions for this node
        const loggedId = LOGGED && LOGGED.id !== undefined && LOGGED.id !== null ? String(LOGGED.id) : null;
        const publisherId = SERVER_PUBLISHER && SERVER_PUBLISHER.id ? String(SERVER_PUBLISHER.id) : (media.user_id ? String(media.user_id) : null);
        const commenterId = node.commenter_id !== null ? String(node.commenter_id) : null;
        const commenterLvl = node.commenter_lvl !== null ? Number(node.commenter_lvl) : null;

        // styling: prefer server-provided node.type, fallback to legacy checks
        let ctype = node.type || null;
        if (!ctype) {
          if (commenterId && publisherId && commenterId === publisherId) ctype = 'publisher';
          else if (commenterLvl !== null && commenterLvl < 3) ctype = 'admin';
          else if (commenterLvl === 2) ctype = 'mod';
          else ctype = 'regular';
        }
        div.classList.add(ctype);
        if (ctype === 'admin') div.style.position = 'relative';
        // attach a visible badge to the header (so child comments keep their own badge)
        const typeBadge = document.createElement('span');
        typeBadge.className = 'comment-badge ' + ctype + '-badge';
        typeBadge.textContent = ctype.toUpperCase();
        typeBadge.style.marginLeft = '8px';
        header.appendChild(typeBadge);

        // REPLY button (only if allowed)
        if (canReply()){
          const replyBtn = document.createElement('button'); replyBtn.textContent='Rispondi';
          replyBtn.addEventListener('click', ()=> {
            const ta = el('comment-text');
            // prefill mention only if a real username exists
            const prof = node.username;
            ta.value = prof ? `@${prof} ` : `${node.display_name} `;
            ta.focus();
            // set active reply id and show context (both in-memory and in hidden input)
            replyToCommentId = node.id;
            const hidden = el('parent-comment-id');
            if (hidden) hidden.value = String(node.id);
            const ctx = el('reply-context');
            if (ctx) {
              ctx.style.display = 'block';
              el('reply-to-name').textContent = prof ? `@${prof}` : node.display_name;
            }
            // expose the commenter info for external integrations / forms
            try {
              window.COMMENTER = { id: node.raw && node.raw.user && node.raw.user.id ? node.raw.user.id : node.username ? node.username : null, username: node.username || null, lvl: node.raw && node.raw.user && node.raw.user.lvl !== undefined ? Number(node.raw.user.lvl) : (node.commenter_lvl !== undefined ? Number(node.commenter_lvl) : null) };
            } catch(e){ window.COMMENTER = { id: null, username: node.username || null, lvl: null }; }
          });
          actions.appendChild(replyBtn);
        }

        // EDIT button (own comment or any if canEditAny)
        const canEditThis = (loggedId && commenterId && loggedId === commenterId) || canEditAny();
        if (canEditThis){
          const editBtn = document.createElement('button'); editBtn.textContent='Edit'; editBtn.style.marginLeft='8px';
          editBtn.addEventListener('click', ()=>{
            // inline edit UI
            const ta = document.createElement('textarea'); ta.value = node.text; ta.style.width='100%'; ta.style.marginTop='8px';
            const save = document.createElement('button'); save.textContent='Save'; save.style.marginLeft='6px';
            const cancel = document.createElement('button'); cancel.textContent='Cancel'; cancel.style.marginLeft='6px';
            div.appendChild(ta); div.appendChild(save); div.appendChild(cancel);
            save.addEventListener('click', async ()=>{
              const newText = ta.value.trim(); if(!newText) return alert('Text vuoto');
              try{
                const r = await fetch('/show/comment/edit', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ comment_id: node.id, new_text: newText }) });
                const j = await r.json().catch(()=>({}));
                if(r.ok && j.status === 'OK') { await loadComments(); } else { alert('Edit failed'); }
              } catch(e){ console.error(e); alert('Network error'); }
            });
            cancel.addEventListener('click', ()=>{ ta.remove(); save.remove(); cancel.remove(); });
          });
          actions.appendChild(editBtn);
        }

        // DELETE button (own comment or allowed by admin/publisher)
        const canDeleteThis = (loggedId && commenterId && loggedId === commenterId) || canDeleteAny();
        if (canDeleteThis){
          const deleteBtn = document.createElement('button'); deleteBtn.textContent='Delete'; deleteBtn.style.marginLeft='8px'; deleteBtn.style.background='#c33'; deleteBtn.style.color='#fff';
          deleteBtn.addEventListener('click', async ()=>{
            if(!confirm('Sei sicuro di voler eliminare questo commento?')) return;
            try{
              const r = await fetch('/show/comment/delete', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ comment_id: node.id }) });
              const j = await r.json().catch(()=>({}));
              if(r.ok && j.status === 'OK') { await loadComments(); } else { alert('Delete failed'); }
            } catch(e){ console.error(e); alert('Network error'); }
          });
          actions.appendChild(deleteBtn);
        }

        div.appendChild(header); div.appendChild(body); div.appendChild(actions);

        // children: collapse large threads and use a "see more" loader (counts replies including nested replies)
        if(node.children && node.children.length){
          const totalReplies = countDescendants(node);
          const wrap = document.createElement('div');
          wrap.className = 'children';

          if(totalReplies > 3){
            const btn = document.createElement('button');
            btn.className = 'see-more-btn';
            btn.textContent = `Mostra altre ${totalReplies} risposte`;
            btn.addEventListener('click', ()=>{
              // prevent double-click
              btn.disabled = true; btn.textContent = 'Caricamento...';
              // render all children (preserves original order and nested replies)
              node.children.forEach(child => wrap.appendChild(renderNode(child)));
              btn.remove();
            });
            div.appendChild(btn);
            // do not render replies yet (they will be appended to wrap when button clicked)
            div.appendChild(wrap);
          } else {
            // small threads: render directly
            node.children.forEach(child => wrap.appendChild(renderNode(child)));
            div.appendChild(wrap);
          }
        }
        return div;
      };

      // append roots
      // Sort roots (most recent first) and children recursively
      const parseDate = s => { const d = new Date(String(s)); return isNaN(d) ? 0 : d.getTime(); };
      const sortRecursive = node => {
        if(node.children && node.children.length){
          node.children.sort((a,b)=> parseDate(b.when) - parseDate(a.when));
          node.children.forEach(sortRecursive);
        }
      };
      roots.sort((a,b)=> parseDate(b.when) - parseDate(a.when));
      roots.forEach(sortRecursive);

      // Lazy render roots in batches of 10 (most recent on top)
      const BATCH = 10;
      let rendered = 0;
      list.innerHTML = '';
      const sentinel = document.createElement('div'); sentinel.id = 'comments-sentinel';
      sentinel.style.padding = '12px'; sentinel.style.textAlign = 'center'; sentinel.style.color = 'var(--muted)'; sentinel.textContent = 'Caricamento...';

      const renderNext = () => {
        const slice = roots.slice(rendered, rendered + BATCH);
        slice.forEach(r => list.appendChild(renderNode(r)));
        rendered += slice.length;
        if(rendered >= roots.length){
          // all rendered
          if (sentinel.parentNode) sentinel.remove();
          if(rendered === 0) list.textContent = 'Nessun commento';
        } else {
          if (!sentinel.parentNode) list.appendChild(sentinel);
        }
      };

      // IntersectionObserver to trigger more renders
      const io = new IntersectionObserver(entries => { if(entries[0].isIntersecting) renderNext(); }, { rootMargin: '200px', threshold: 0.01 });
      // start
      renderNext();
      if (roots.length > rendered) io.observe(sentinel);
      else if (sentinel.parentNode) sentinel.remove();
    } catch(e){
      console.error('[comments] loadComments error:', e);
      console.error(e); el('comments-list').textContent = 'Errore nel caricamento commenti';
    }
   }

  // hide send UI if user is restricted/banned
  const _sendBtn = el('comment-send'); const _commentInput = el('comment-text');
  if(!canComment()){
    if(_sendBtn) _sendBtn.style.display = 'none';
    if(_commentInput){ _commentInput.setAttribute('disabled','true'); _commentInput.setAttribute('placeholder','Non puoi commentare'); }
  } else {
    if(_sendBtn) _sendBtn.style.display = '';
    if(_commentInput) _commentInput.removeAttribute('disabled');
  }

  if(_sendBtn){ _sendBtn.addEventListener('click', async ()=>{
    const text = el('comment-text').value.trim();
    if(!text) return alert('Commento vuoto');
    console.debug('[comments] sending comment for media_id=', mediaId, 'text=', text);
    try {
      const payload = { media_id: mediaId, text };
      // always check hidden parent field first, fallback to replyToCommentId
      const parentValEl = el('parent-comment-id');
      const parentVal = (parentValEl && parentValEl.value) ? parentValEl.value : replyToCommentId;
      if (parentVal !== null && parentVal !== undefined && String(parentVal).trim() !== '') {
        const pid = Number(parentVal);
        if (!isNaN(pid)) {
          payload.parent_comment_id = pid;
          payload.parent_id = pid;
          payload.parent = pid;
        }
      }
      const r = await fetch('/show/comment', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      console.debug('[comments] post returned status=', r.status, 'ok=', r.ok);
      let jr = null;
      try { jr = await r.clone().json(); console.debug('[comments] post returned json=', jr); } catch(e){ console.debug('[comments] post returned non-json'); }
      if(r.ok){ el('comment-text').value = ''; await loadComments(); } else { alert('Errore durante l\'invio del commento'); }
      // clear reply context after send attempt
      clearReply();
    } catch(e){ console.error(e); alert('Errore di rete'); }
  }); }


  // ---------- LOAD MEDIA ----------
  try {
    // prefer server-injected object if available to avoid extra round-trip
    let media = window.INITIAL_MEDIA || null;
    // prefer the concise server-injected object when available
    let loggedUser = window.LOGGED || window.SERVER_USER || null;
    // also expose server-provided publisher/commenter shortcuts
    const serverPublisher = window.PUBLISHER || null;
    const serverCommenter = window.COMMENTER || null;

    if(!media){
      const res = await fetch(`/show/data?media_id=${encodeURIComponent(mediaId)}`);
      const j = await res.json();
      if(!res.ok || j.error){ el('media-title').textContent = j.error || 'Errore'; return; }
      media = j.media || j;
      if(j.user) loggedUser = j.user;
      // keep server-injected user if present
      if(!loggedUser && window.SERVER_USER) loggedUser = window.SERVER_USER;
    } else {
      // if we had initial media but server didn't inject user, try to use injected SERVER_USER
      if(!loggedUser && window.SERVER_USER) loggedUser = window.SERVER_USER;
    }

    // normalize canonical keys
    media.type = (media.type || media.media_type || '').toString().toLowerCase();
    media.user_id = media.user_id || media.uploader_id || media.owner_id || media.owner || media.uploader || media.publisher || null;
    media.username = media.username || media.uploader || media.owner || media.user || null;

    el('media-title').textContent = media.title || media.name || media.filename || 'Untitled';

    const uploader = media.username || null;
    const uploaderEl = el('media-uploader');
    if (uploader && uploaderEl) {
      const a = document.createElement('a');
      a.href = `/home/?form_type=profile&username=${encodeURIComponent(uploader)}`;
      a.textContent = `Pubblicato da: ${uploader}`;
      a.style.color = 'var(--accent-2)'; a.style.textDecoration = 'none'; a.target = '_blank';
      uploaderEl.innerHTML = ''; uploaderEl.appendChild(a);
    } else if (uploaderEl) uploaderEl.textContent = '';

    const backBtn = el('back-to-feed');
    if (backBtn) backBtn.addEventListener('click', () => {
      try {
        const ref = document.referrer || '';
        if (ref && (ref.includes('/feed') || ref.includes('form_type=feed') || ref.includes('/home/?form_type=feed'))) { window.history.back(); } else { window.location.href = '/home/?form_type=feed'; }
      } catch (e) { window.location.href = '/home/?form_type=feed'; }
    });

    const getDownloadUrl = m => {
      let downloadUrl = m.file || m.link || m.url || m.stored_at || '';
      const isRemote = /^https?:\/\//i.test(downloadUrl) || /^data:/i.test(downloadUrl);
      if(downloadUrl && !isRemote){
        const fname = m.filename || (downloadUrl.split('/').pop()) || downloadUrl;
        const proxyType = (m.type || 'document').toLowerCase();
        return `/show/file?file_type=${encodeURIComponent(proxyType)}&filename=${encodeURIComponent(fname)}`;
      }
      return downloadUrl;
    };

    const t = (media.type || '').toLowerCase();
    const downloadUrl = getDownloadUrl(media);
    const filename = media.filename || (media.stored_at ? media.stored_at.split('/').pop() : (media.file || '-'));

    // ---------- OPEN WITH UI ----------
    (function(){
      const openWrap = el('open-with-buttons');
      if(!openWrap) return;
      openWrap.innerHTML = '';
      const apps = [
        {id:'default', label:'Default app'},
        {id:'vlc', label:'VLC'},
        {id:'music', label:'Music'},
        {id:'quicktime', label:'QuickTime'},
        {id:'wmp', label:'Windows Media Player'}
      ];
      const sel = document.createElement('select'); sel.id = 'open-with-select';
      apps.forEach(a=>{ const opt = document.createElement('option'); opt.value = a.id; opt.textContent = a.label; sel.appendChild(opt); });
      const otherInput = document.createElement('input'); otherInput.placeholder = 'Or enter app id (e.g. vlc)'; otherInput.style.marginLeft = '8px'; otherInput.id = 'open-with-other';

      const btn = document.createElement('button'); btn.textContent = 'Open'; btn.style.marginLeft = '8px';
      btn.addEventListener('click', async ()=>{
        const app_id = (otherInput.value || '').trim() || sel.value;
        try{
          btn.disabled = true; btn.textContent = 'Opening...';
          const resp = await fetch('/show/open_with', {method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify({media_id: mediaId, app_id})});
          if(resp.ok){
            const j = await resp.json().catch(()=>({status:'OK'}));
            if(j && j.status === 'OK'){
              alert(`Opened with ${app_id}`);
            } else {
              alert(j && j.error_msg ? `Error: ${j.error_msg}` : 'Opened (no details)');
            }
          } else {
            const j = await resp.json().catch(()=>null);
            alert(j && j.error_msg ? `Error: ${j.error_msg}` : 'Failed to open with chosen app');
          }
        }catch(e){ console.error(e); alert('Error during open request'); }
        finally{ btn.disabled=false; btn.textContent='Open'; }
      });

      openWrap.appendChild(sel); openWrap.appendChild(otherInput); openWrap.appendChild(btn);
    })();

    // display media element
    const setDurationFromElement = (elMedia) => {
      if(!elMedia) return; 
      const onLoaded = () => {
        const d = elMedia.duration || 0;
        const disp = formatTime(d);
        const durEl = document.querySelector('[data-field="Duration"] .meta-value');
        if(durEl) durEl.textContent = disp;
      };
      elMedia.addEventListener('loadedmetadata', onLoaded, {once:true});
    };

    if(t==='video' || (filename && filename.match(/\.(mp4|mov|avi|webm)$/i))){
      el('video-box').classList.remove('hidden'); el('video-source').src = downloadUrl || media.link || ''; el('video-player').load(); setDurationFromElement(el('video-player'));
    } else if(t==='audio' || (filename && filename.match(/\.(mp3|wav|m4a|ogg)$/i))){
      el('audio-box').classList.remove('hidden'); el('audio-source').src = downloadUrl || ''; el('audio-player').load(); setDurationFromElement(el('audio-player'));
    } else if(t==='document'){
      el('document-box').classList.remove('hidden'); el('document-viewer').src = downloadUrl || '';
    } else if(t==='concert' || (media.link && /youtube\.com|youtu\.be/i.test(media.link))){
      el('concert-box').classList.remove('hidden'); const vid = extractYouTubeId(media.link || ''); el('concert-iframe').src = vid ? `https://www.youtube.com/embed/${vid}?rel=0` : media.link || '';
    }

    // ---------- DETAILS ----------
    const deriveFormat = () => media.file_format || media.format || (filename && filename.includes('.') ? filename.split('.').pop().toLowerCase() : '-');
    const deriveDuration = () => media.duration_display || (media.duration_seconds ? formatTime(media.duration_seconds) : (media.duration ? formatTime(media.duration) : '-'));

    const details = [
      {k:'Authors', v: safeJoin((media.author_names && media.author_names.length) ? media.author_names : (media.authors || []), '-')},
      {k:'Genre', v: (media.tags && media.tags.length) ? safeJoin(media.tags, '-') : (Array.isArray(media.genres) && media.genres.length ? media.genres.join(', ') : '-')},
      {k:'Composition year', v: media.year || media.date || media.composition_year || '-'},
      {k:'Type', v: media.type || '-'},
      {k:'Filename', v: filename || '-'},
      {k:'Format', v: deriveFormat()},
      {k:'Duration', v: deriveDuration()},
      {k:'Recording date', v: media.recording_date || '-'},
      {k:'Recording location', v: media.recording_location || '-'},
      {k:'Location (stored_at)', v: media.stored_at || '-'},
      {k:'Link', v: media.link || '-'},
      {k:'Pages', v: media.pages || '-'},
      {k:'Description', v: media.description || media.full_description || '-'}
    ];

    const container = el('media-details-content');
    container.innerHTML = '';
    const grid = document.createElement('div'); grid.className='meta-grid';
    details.forEach(d=>{
      const item = document.createElement('div'); item.className='meta-item';
      const title = document.createElement('strong'); title.style.color = 'var(--accent-2)'; title.textContent = d.k;
      const value = document.createElement('div'); value.className='meta-value'; value.style.marginTop='6px'; value.style.color='var(--muted)'; value.textContent = d.v;
      item.appendChild(title); item.appendChild(value); grid.appendChild(item);
    });
    container.appendChild(grid);

    // performers
    if(media.performers && media.performers.length){
      const ptitle = document.createElement('div'); ptitle.className='list-title'; ptitle.textContent='Performers';
      const plist = document.createElement('div'); plist.className='performers-list';
      media.performers.forEach(p=>{
        const it = document.createElement('div'); it.className='performer-item';
        const name = (p.name || p.performer || p.username || p); const inst = (p.instruments && p.instruments.length) ? 'Instruments: '+p.instruments.join(', ') : '';
        it.innerHTML = `<strong>${name}</strong><div style="color:var(--muted)">${inst}</div>`; plist.appendChild(it);
      });
      container.appendChild(ptitle); container.appendChild(plist);
    }

    // sections/subtracks
    if(media.segments && media.segments.length){
      const stitle = document.createElement('div'); stitle.className='list-title'; stitle.textContent='Segments';
      const slist = document.createElement('div'); slist.className='segments-list';
      media.segments.forEach(s=>{
        const it = document.createElement('div'); it.className='segment-item';
        const start = s.start_time || s.start || 0; const end = s.end_time || s.end || 0;
        it.innerHTML = `<strong>${formatTime(start)} â€” ${end ? formatTime(end) : ''}</strong><div style="color:var(--muted)">${s.note_text||s.content||''}</div>`; slist.appendChild(it);
      });
      container.appendChild(stitle); container.appendChild(slist);
    }

    // linked media (if any)
    (function(){
      let lm = media.linked_media || [];
      if(typeof lm === 'string'){
        try{ lm = JSON.parse(lm); }catch(e){ lm = []; }
      }
      if(!Array.isArray(lm) || !lm.length) return;
      const ltitle = document.createElement('div'); ltitle.className='list-title'; ltitle.textContent='Linked media';
      const llist = document.createElement('div'); llist.className='linked-media-list';
      lm.forEach(it=>{
        const item = document.createElement('div'); item.className='linked-media-item';
        const typ = (it.type || it.media_type || '').toLowerCase();
        const fname = it.filename || (it.stored_at ? it.stored_at.split('/').pop() : '');
        const display = it.title || fname || (it.name||'file');
        let href = '#';
        if(it.id){ href = `${window.location.pathname}?media_id=${encodeURIComponent(it.id)}`; }
        else if(fname && typ){ href = `/show/file?file_type=${encodeURIComponent(typ)}&filename=${encodeURIComponent(fname)}`; }
        const a = document.createElement('a'); a.href = href; a.textContent = display; a.style.marginRight='12px';
        item.appendChild(a);
        // small actions for song/video
        if(typ==='song' && href.startsWith('/show/')) {
          const play = document.createElement('button'); play.className='play'; play.textContent='Play'; play.addEventListener('click', async (ev)=>{ ev.preventDefault(); try{ const resp = await fetch(href, {credentials:'same-origin'}); if(!resp.ok){ alert('Unable to fetch audio'); return; } const blob = await resp.blob(); const url = URL.createObjectURL(blob); const audio = new Audio(url); audio.play(); setTimeout(()=>URL.revokeObjectURL(url),60000);}catch(e){console.error(e);alert('Playback error')}}); item.appendChild(play);
        }
        llist.appendChild(item);
      });
      container.appendChild(ltitle); container.appendChild(llist);
    })();

    // download (direct)
    if(downloadUrl){
      const dl = document.createElement('a'); dl.id='download-btn'; dl.href = downloadUrl; dl.textContent='Download'; dl.style.marginTop='12px'; dl.style.display='inline-block'; dl.style.marginRight='8px';
      // if same-origin proxy, intercept and force blob download
      dl.addEventListener('click', async (ev) => {
        try {
          if (downloadUrl.startsWith('/show/')) {
            ev.preventDefault();
            const resp = await fetch(downloadUrl, {credentials:'same-origin'});
            if(!resp.ok){ alert('Download fallito'); return; }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename || ''; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          }
        } catch(e){ console.error(e); alert('Errore durante il download'); }
      });
      container.appendChild(dl);
    }

    // ---------- ADMIN ACTIONS (edit/delete) ----------
    (function createAdminActions(){
      const adminWrap = document.getElementById('admin-actions');
      adminWrap.innerHTML = '';
      if(!adminWrap) return;

      // normalize loggedUser fields
      const currentUser = loggedUser || null;
      const currentLvl = currentUser && (currentUser.lvl !== undefined) ? Number(currentUser.lvl) : null;
      const currentUserId = currentUser && (currentUser.id || currentUser.user_id) ? String(currentUser.id || currentUser.user_id) : null;
      // prefer explicit server-supplied publisher info when available
      const publisherId = (serverPublisher && serverPublisher.id) ? String(serverPublisher.id) : (media.user_id ? String(media.user_id) : null);
      const publisherUsername = (serverPublisher && serverPublisher.username) ? String(serverPublisher.username) : (media.username ? String(media.username) : null);
      const publisherLvl = (serverPublisher && serverPublisher.lvl !== undefined) ? Number(serverPublisher.lvl) : (media.publisher_lvl !== undefined ? Number(media.publisher_lvl) : null);

      const isAdminLevel = [0,1,2].includes(Number(currentLvl));
      const isPublisher = (currentUserId && publisherId && currentUserId === publisherId) || (currentUser && currentUser.username && publisherUsername && currentUser.username === publisherUsername);

      if(!(currentUser && (isAdminLevel || isPublisher))) return;

      const editBtn = document.createElement('button'); editBtn.id='editButton'; editBtn.type='button'; editBtn.textContent='Edit metadata'; editBtn.style.marginRight='8px';
      const deleteBtn = document.createElement('button'); deleteBtn.id='deleteButton'; deleteBtn.type='button'; deleteBtn.textContent='Delete'; deleteBtn.style.background='#c33'; deleteBtn.style.color='#fff';

      adminWrap.appendChild(editBtn); adminWrap.appendChild(deleteBtn);

      // populate & show edit form
      editBtn.addEventListener('click', ()=> {
        // populate fields (allow clearing)
        document.getElementById('edit-title').value = media.title || '';
        document.getElementById('edit-description').value = media.description || '';
        document.getElementById('edit-year').value = media.year || '';
        document.getElementById('edit-duration').value = media.duration || media.duration_seconds || '';
        document.getElementById('edit-recording-date').value = media.recording_date || '';
        document.getElementById('edit-recording-location').value = media.recording_location || '';
        document.getElementById('edit-stored-at').value = media.stored_at || '';
        document.getElementById('edit-link').value = media.link || '';
        document.getElementById('edit-format').value = media.format || media.file_format || '';
        document.getElementById('edit-pages').value = media.pages || '';
        document.getElementById('edit-is-author').checked = !!media.is_author;
        document.getElementById('edit-is-performer').checked = !!media.is_performer;
        document.getElementById('edit-genres').value = Array.isArray(media.tags) ? media.tags.join(', ') : (Array.isArray(media.genres) ? media.genres.join(', ') : '');
        document.getElementById('edit-authors').value = Array.isArray(media.author_names) ? media.author_names.join(', ') : (Array.isArray(media.authors) ? media.authors.join(', ') : '');
        document.getElementById('edit-performers').value = Array.isArray(media.performers) ? media.performers.join(', ') : '';

        showModal('editForm', true);
      });

      document.getElementById('edit-cancel').addEventListener('click', ()=> { showModal('editForm', false); });

      document.getElementById('edit-save').addEventListener('click', async ()=> {
        const btn = document.getElementById('edit-save');
        btn.disabled = true;
        const prevText = btn.textContent;
        btn.textContent = 'Saving...';
        try {
          // build updates: include fields even if empty (to clear them)
          const updates = {};
          const setIfPresent = (key, val) => { updates[key] = (val === '' ? null : val); };

          setIfPresent('title', document.getElementById('edit-title').value.trim());
          setIfPresent('description', document.getElementById('edit-description').value.trim());
          setIfPresent('year', document.getElementById('edit-year').value ? Number(document.getElementById('edit-year').value) : null);
          setIfPresent('duration', document.getElementById('edit-duration').value ? Number(document.getElementById('edit-duration').value) : null);
          setIfPresent('recording_date', document.getElementById('edit-recording-date').value || null);
          setIfPresent('recording_location', document.getElementById('edit-recording-location').value.trim() || null);
          setIfPresent('stored_at', document.getElementById('edit-stored-at').value.trim() || null);
          setIfPresent('link', document.getElementById('edit-link').value.trim() || null);
          setIfPresent('format', document.getElementById('edit-format').value.trim() || null);
          setIfPresent('pages', document.getElementById('edit-pages').value ? Number(document.getElementById('edit-pages').value) : null);

          // proper JS booleans
          updates['is_author'] = document.getElementById('edit-is-author').checked;
          updates['is_performer'] = document.getElementById('edit-is-performer').checked;

          // relations: comma separated -> send as array (server will normalize)
          const genresRaw = document.getElementById('edit-genres').value.trim();
          updates['genres'] = genresRaw === '' ? null : genresRaw.split(',').map(s => s.trim()).filter(Boolean);

          const authorsRaw = document.getElementById('edit-authors').value.trim();
          updates['authors'] = authorsRaw === '' ? null : authorsRaw.split(',').map(s => s.trim()).filter(Boolean);

          const perfRaw = document.getElementById('edit-performers').value.trim();
          updates['performers'] = perfRaw === '' ? null : perfRaw.split(',').map(s => s.trim()).filter(Boolean);
          const resp = await fetch('/show/edit', {
            method: 'POST',
            credentials: 'same-origin',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ media_id: mediaId, updates: updates, type: media.type || null })
          });
          const json = await resp.json().catch(()=>({}));
          if (resp.ok && (json.status === 'OK' || json.status === undefined)) {
            showModal('editForm', false);
            alert('Salvato');
            // reload to reflect persisted changes
            window.location.reload();
          } else {
            alert('Save failed: ' + (json.error_msg || JSON.stringify(json) || resp.status));
          }
        } catch (e) {
          console.error(e);
          alert('Network error during save');
        } finally {
          btn.disabled = false;
          btn.textContent = prevText;
        }
       });
 
      // delete handlers
      deleteBtn.addEventListener('click', ()=> { showModal('confirmationDialog', true); });
      document.getElementById('confirmCancel').addEventListener('click', ()=> { showModal('confirmationDialog', false); });
 
       document.getElementById('confirmDelete').addEventListener('click', async ()=>{
         try {
           const r = await fetch('/show/delete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ media_id: mediaId, type: media.type || null }) });
           const j = await r.json();
           if (r.ok && (j.status === 'OK' || j.status === undefined)) {
             alert('Deleted');
             window.location.href = '/home/?form_type=feed';
           } else {
             alert('Delete failed: ' + (j.error_msg || JSON.stringify(j)));
             showModal('confirmationDialog', false);
           }
         } catch(e){ console.error(e); alert('Network error'); showModal('confirmationDialog', false); }
       });
 
     })();
 
     await loadComments();
 
   } catch(err){
    console.error(err); el('media-title').textContent = "Errore di rete";
  }
})();
</script>
</body>
</html>