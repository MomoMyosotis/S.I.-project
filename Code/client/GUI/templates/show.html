<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Media Viewer</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='show_style.css') }}">
  <script>
    // server-injected prefetch (may be "null")
    window.INITIAL_MEDIA = {{ INITIAL_MEDIA|safe }};
    window.SERVER_USER = {{ SERVER_USER|safe }};
  </script>
</head>
<body>
  <div class="media-container">
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px;">
      <button id="back-to-feed" type="button">Torna al Feed</button>
      <h1 id="media-title">Caricamento...</h1>
      <div id="admin-actions" style="margin-left:auto;display:flex;gap:8px;"></div>
    </div>

    <div id="media-uploader" style="margin-bottom:8px;color:var(--muted)"></div>

    <div id="media-display" class="media-display">
      <div id="video-box" class="hidden">
        <video id="video-player" controls><source id="video-source"></video>
      </div>
      <div id="audio-box" class="hidden">
        <audio id="audio-player" controls><source id="audio-source"></source></audio>
      </div>
      <div id="document-box" class="hidden">
        <iframe id="document-viewer" src="" frameborder="0"></iframe>
      </div>
      <div id="concert-box" class="hidden">
        <iframe id="concert-iframe" src="" frameborder="0" allowfullscreen></iframe>
        <div id="concert-subtracks"></div>
      </div>
    </div>

    <div id="media-details-content"></div>

    <div id="open-with-area" style="margin-top:12px">
      <strong>Apri con:</strong>
      <div id="open-with-buttons" style="margin-top:8px"></div>
    </div>

    <!-- EDIT FORM (hidden) -->
    <div id="modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div id="editForm" class="form-modal" role="dialog" aria-modal="true" aria-labelledby="edit-title-h">
      <div class="modal-panel">
        <h3 id="edit-title-h">Edit metadata</h3>
        <div class="modal-grid">
          <label>Title<br><input id="edit-title" style="width:100%"></label>
          <label>Year<br><input id="edit-year" type="number" style="width:100%"></label>
          <label>Duration (sec)<br><input id="edit-duration" type="number" style="width:100%"></label>
          <label>Recording date<br><input id="edit-recording-date" type="date" style="width:100%"></label>
          <label>Recording location<br><input id="edit-recording-location" style="width:100%"></label>
          <label>Location (stored_at)<br><input id="edit-stored-at" style="width:100%"></label>
          <label>Link<br><input id="edit-link" style="width:100%"></label>
          <label>Format / File format<br><input id="edit-format" style="width:100%"></label>
          <label>Pages (document)<br><input id="edit-pages" type="number" style="width:100%"></label>
          <label>Is author<br><input id="edit-is-author" type="checkbox"></label>
          <label>Is performer<br><input id="edit-is-performer" type="checkbox"></label>
          <label>Genres (comma separated)<br><input id="edit-genres" style="width:100%"></label>
          <label>Authors (comma separated)<br><input id="edit-authors" style="width:100%"></label>
          <label>Performers (comma separated)<br><input id="edit-performers" style="width:100%"></label>
        </div>
        <div style="margin-top:8px">
          <label>Description<br><textarea id="edit-description" style="width:100%;height:120px"></textarea></label>
        </div>
        <div class="modal-actions">
          <button id="edit-cancel" type="button">Cancel</button>
          <button id="edit-save" type="button" style="margin-left:8px">Save</button>
        </div>
      </div>
    </div>

    <!-- DELETE CONFIRM -->
    <div id="confirmationDialog" class="form-modal confirmation" role="dialog" aria-modal="true" aria-labelledby="confirm-h">
      <div class="modal-panel">
        <h3 id="confirm-h" style="margin-top:0;color:#ff2770">Confirm deletion</h3>
        <div>Sei sicuro di voler eliminare questo media?</div>
        <div class="modal-actions">
          <button id="confirmCancel">Cancel</button>
          <button id="confirmDelete" style="margin-left:8px">Delete</button>
        </div>
      </div>
    </div>

    <!-- COMMENTS -->
    <div class="comments-area" id="comments-area" style="margin-top:20px">
      <h2>Commenti</h2>
      <div id="comments-list">Caricamento commenti...</div>
      <div class="comment-input" style="margin-top:12px">
        <textarea id="comment-text" placeholder="Scrivi un commento..."></textarea>
        <!-- store parent comment id when replying -->
        <input type="hidden" id="comment-parent-id" value="">
        <button id="comment-send">Invia</button>
      </div>
    </div>
  </div>

<script>
(async function(){
  function showModal(id, show = true){
    const el = document.getElementById(id);
    const backdrop = document.getElementById('modal-backdrop');
    if(!el) return;
    if(show){
      el.classList.add('open');
      if(backdrop) backdrop.style.display = 'block';
      el.setAttribute('aria-hidden', 'false');
    } else {
      el.classList.remove('open');
      if(backdrop) backdrop.style.display = 'none';
      el.setAttribute('aria-hidden', 'true');
    }
  }

  const qs = name => new URLSearchParams(window.location.search).get(name);
  const mediaId = qs('media_id');
  if(!mediaId){ document.getElementById('media-title').textContent = "Media non trovato"; return; }
  const el = id => document.getElementById(id);

  // ---------- HELPERS ----------
  const formatTime = s => {
    s = Number(s) || 0;
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60);
    return `${m}:${sec.toString().padStart(2,'0')}`;
  };

  // Format many timestamp shapes into "DD mon. YYYY HH:MM" (e.g. "12 dec. 2025 16:39")
  const formatTimestamp = (ts) => {
    if(!ts) return "";
    try {
      let s = String(ts).trim();
      // support "YYYY-MM-DD" -> add time to be parseable
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) s += 'T00:00:00';
      // common backend uses space between date and time
      s = s.replace(' ', 'T');
      const d = new Date(s);
      if (isNaN(d.getTime())) return s;
      const day = String(d.getDate()).padStart(2,'0');
      const months = ['jan.','feb.','mar.','apr.','may.','jun.','jul.','aug.','sep.','oct.','nov.','dec.'];
      const mon = months[d.getMonth()] || '';
      const year = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${day} ${mon} ${year} ${hh}:${mm}`;
    } catch (e) {
      return String(ts);
    }
  };
  const extractYouTubeId = url => {
    if(!url) return null;
    const m = url.match(/(?:v=|\/embed\/|youtu\.be\/)([A-Za-z0-9_-]{6,})/);
    return m ? m[1] : null;
  };

  const safeJoin = (arr, fallback='-') => {
    if(!arr) return fallback;
    if(Array.isArray(arr) && arr.length){
      const mapped = arr.map(a => {
        if(!a) return '';
        if(typeof a === 'string' || typeof a === 'number') return String(a);
        if(a.name) return a.name;
        if(a.username) return a.username;
        if(a.performer) return a.performer;
        return JSON.stringify(a);
      }).filter(Boolean);
      return mapped.length ? mapped.join(', ') : fallback;
    }
    return fallback;
  };

  // ---------- COMMENTS ----------
  async function loadComments(){
    try {
      console.debug('[comments] loadComments start for media_id=', mediaId);
      const res = await fetch(`/show/comments?media_id=${encodeURIComponent(mediaId)}`);
      console.debug('[comments] fetch completed, response status=', res.status, 'ok=', res.ok);
      if(!res.ok) throw new Error('Fetch error');
      let arr = await res.json();
      console.debug('[comments] raw json payload received:', arr);

      // normalize many possible server shapes into an array of comments
      if(!arr) arr = [];
      if(!Array.isArray(arr)){
        if (Array.isArray(arr.results)) arr = arr.results;
        else if (Array.isArray(arr.response)) arr = arr.response;
        else if (Array.isArray(arr.comments)) arr = arr.comments;
        else if (arr && typeof arr === 'object' && Object.keys(arr).length && (arr.comment || arr.item)) {
          const single = arr.comment || arr.item;
          arr = Array.isArray(single) ? single : [single];
        } else {
          // unknown shape -> empty
          arr = [];
        }
      }
      console.debug('[comments] normalized array length=', arr.length);

      const list = el('comments-list');
      list.innerHTML = '';
      if(!arr.length){ list.textContent = 'Nessun commento'; return; }
      console.debug('[comments] rendering', arr.length, 'comments');

      const extractAuthor = (c) => {
        // canonical: return { username, display_name, avatar }
        if(!c) return { username: null, display_name: 'Anonimo', avatar: '/static/images/no pp.jpg' };
        // server will often send username / display_name / avatar
        const avatarKeys = ['avatar','avatar_url','profile_pic','picture','image','photo','gravatar','profile_image'];
        let username = (typeof c.username === 'string' ? c.username : null);
        if(!username && c.user && typeof c.user === 'object' && typeof c.user.username === 'string') username = c.user.username;
        if(!username && typeof c.author_username === 'string') username = c.author_username;
        if(!username && typeof c.author === 'string') username = c.author;

        let display_name = c.display_name || c.author || c.name || (username || null) || 'Anonimo';

        let avatar = c.avatar || null;
        if(!avatar && c.user && typeof c.user === 'object'){
          avatar = c.user.avatar || c.user.avatar_url || c.user.picture || c.user.profile_image || c.user.profile_pic || null;
        }
        for (const k of avatarKeys) {
          if (!avatar && c[k]) { avatar = c[k]; break; }
        }

        // normalize avatar:
        if (typeof avatar === 'string') {
          avatar = avatar.trim();
          if (!avatar) {
            avatar = '/static/images/no pp.jpg';
          } else if (!/^https?:\/\//i.test(avatar) && !/^data:/i.test(avatar) && !avatar.startsWith('/')) {
            // bare filename -> use same profile picture proxy as the feed
            avatar = `/profile/picture/${encodeURIComponent(avatar)}`;
          }
        } else {
          avatar = '/static/images/no pp.jpg';
        }

        return { username: username || null, display_name: display_name, avatar: avatar || '/static/images/no pp.jpg' };
      };

      // Build canonical nodes
      const getId = c => c.id || c.comment_id || c._id || c.commentId || null;
      const getParentId = c => c.parent_comment_id || c.parent || c.reply_to || c.parentCommentId || null;
      const nodes = [];
      const map = {};
      arr.forEach(c=>{
        const id = getId(c);
        if(!id) return; // skip invalid
        const parent = getParentId(c);
        const who = extractAuthor(c);
        const node = {
          id: String(id),
          parent_id: parent ? String(parent) : null,
          username: who.username || null,
          display_name: who.display_name || 'Anonimo',
          avatar: who.avatar || null,
          when: c.created_at || c.date || c.createdAt || '',
          text: c.text || c.content || c.body || '',
          raw: c,
          children: []
        };
        nodes.push(node);
        map[node.id] = node;
      });

      // attach children
      const roots = [];
      nodes.forEach(n=>{
        if(n.parent_id && map[n.parent_id]){
          map[n.parent_id].children.push(n);
          n._parent = map[n.parent_id];
        } else {
          roots.push(n);
        }
      });

      // recursive renderer
      const renderNode = (node) => {
        const div = document.createElement('div');
        div.className = 'comment';
        div.id = `comment-${node.id}`;
        // header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        if (node.avatar) {
          const img = document.createElement('img');
          img.src = node.avatar;
          img.alt = node.username || node.display_name || 'avatar';
          img.style.width = '32px';
          img.style.height = '32px';
          img.style.borderRadius = '50%';
          img.style.marginRight = '8px';
          img.style.objectFit = 'cover';
          // fallback if avatar path 404s
          img.onerror = () => { img.onerror = null; img.src = '/static/images/no pp.jpg'; };
          header.appendChild(img);
        }
        const whoLink = document.createElement('a');
        // display name shown always, profile link only if we have a real username
        if (node.username) {
          whoLink.href = `/home/?form_type=profile&username=${encodeURIComponent(node.username)}`;
          whoLink.target = '_blank';
          whoLink.style.color = 'var(--accent-2)';
          whoLink.style.textDecoration = 'none';
        } else {
          whoLink.href = 'javascript:void(0)';
          whoLink.style.color = 'var(--muted)';
          whoLink.style.textDecoration = 'none';
        }
        whoLink.textContent = node.display_name;
        header.appendChild(whoLink);

        // small timestamp + optional parent link (showing only clickable parent username)
        const meta = document.createElement('div');
        meta.style.marginLeft = '8px';
        const small = document.createElement('small');
        small.style.color = 'var(--muted)';
        // display friendly formatted timestamp, keep raw value in title for details
        small.textContent = formatTimestamp(node.when) || node.when || '';
        small.title = node.when || '';
        meta.appendChild(small);
        if(node.parent_id && map[node.parent_id]){
          const parent = map[node.parent_id];
          const inrep = document.createElement('span');
          inrep.style.marginLeft = '8px';
          inrep.style.color = 'var(--muted)';
          // if parent has a profile username, link to it; otherwise just reference display name
          if (parent.username) {
            inrep.innerHTML = `in reply to <a href="#comment-${parent.id}" style="color:var(--accent-2);text-decoration:none">@${parent.username}</a>`;
          } else {
            inrep.innerHTML = `in reply to <span style="color:var(--muted)">@${parent.display_name}</span>`;
          }
          meta.appendChild(inrep);
        }
        header.appendChild(meta);

        // body
        const body = document.createElement('div'); body.style.marginTop = '6px'; body.textContent = node.text;

        // actions
        const actions = document.createElement('div'); actions.style.marginTop='6px';
        const replyBtn = document.createElement('button'); replyBtn.textContent='Rispondi';
        replyBtn.addEventListener('click', ()=> {
          const ta = el('comment-text');
          const parentInput = el('comment-parent-id');
          // set parent id so server knows it's a reply
          if (parentInput) parentInput.value = node.id;
          // prefill mention only if a real username exists
          const prof = node.username;
          ta.value = prof ? `@${prof} ` : `${node.display_name} `;
          ta.focus();
        });
        const reportBtn = document.createElement('button'); reportBtn.textContent='Segnala'; reportBtn.style.marginLeft='8px';
        reportBtn.addEventListener('click', async ()=> {
          const reason = prompt('Motivo della segnalazione (opzionale):') || '';
          if(!confirm('Segnalare questo commento?')) return;
          if(!node.id) return alert('Commento non valido');
          await fetch('/show/comment/report', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ comment_id: node.id, reason }) });
          alert('Segnalazione inviata');
        });
        actions.appendChild(replyBtn); actions.appendChild(reportBtn);

        div.appendChild(header); div.appendChild(body); div.appendChild(actions);

        // children
        if(node.children && node.children.length){
          const wrap = document.createElement('div');
          wrap.className = 'children';
          node.children.forEach(child => wrap.appendChild(renderNode(child)));
          div.appendChild(wrap);
        }
        return div;
      };

      // append roots
      roots.forEach(r => list.appendChild(renderNode(r)));
    } catch(e){
      console.error('[comments] loadComments error:', e);
      console.error(e); el('comments-list').textContent = 'Errore nel caricamento commenti';
    }
   }

  el('comment-send').addEventListener('click', async ()=>{
    const text = el('comment-text').value.trim();
    if(!text) return alert('Commento vuoto');
    const parentId = (el('comment-parent-id') && el('comment-parent-id').value) ? el('comment-parent-id').value : null;
    console.debug('[comments] sending comment for media_id=', mediaId, 'text=', text, 'parent=', parentId);
    try {
      const body = { media_id: mediaId, text: text };
      if (parentId) body.parent_comment_id = parentId;
      const r = await fetch('/show/comment', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
      console.debug('[comments] post returned status=', r.status, 'ok=', r.ok);
      let jr = null;
      try { jr = await r.clone().json(); console.debug('[comments] post returned json=', jr); } catch(e){ console.debug('[comments] post returned non-json'); }
      // success only when server responded OK and didn't return an error payload
      if (r.ok && (!jr || (jr && jr.status && String(jr.status).toUpperCase() === 'OK') || (jr && !jr.status))) {
        el('comment-text').value = '';
        if (el('comment-parent-id')) el('comment-parent-id').value = '';
        await loadComments();
      } else {
        alert('Errore durante l\'invio del commento: ' + (jr && jr.error_msg ? jr.error_msg : 'Server error'));
      }
    } catch(e){ console.error(e); alert('Errore di rete'); }
  });

  // ---------- LOAD MEDIA ----------
  try {
    // prefer server-injected object if available to avoid extra round-trip
    let media = window.INITIAL_MEDIA || null;
    let loggedUser = window.SERVER_USER || null;
    if(!media){
      const res = await fetch(`/show/data?media_id=${encodeURIComponent(mediaId)}`);
      const j = await res.json();
      if(!res.ok || j.error){ el('media-title').textContent = j.error || 'Errore'; return; }
      media = j.media || j;
      if(j.user) loggedUser = j.user;
      // keep server-injected user if present
      if(!loggedUser && window.SERVER_USER) loggedUser = window.SERVER_USER;
    } else {
      // if we had initial media but server didn't inject user, try to use injected SERVER_USER
      if(!loggedUser && window.SERVER_USER) loggedUser = window.SERVER_USER;
    }

    // normalize canonical keys
    media.type = (media.type || media.media_type || '').toString().toLowerCase();
    media.user_id = media.user_id || media.uploader_id || media.owner_id || media.owner || media.uploader || media.publisher || null;
    media.username = media.username || media.uploader || media.owner || media.user || null;

    el('media-title').textContent = media.title || media.name || media.filename || 'Untitled';

    const uploader = media.username || null;
    const uploaderEl = el('media-uploader');
    if (uploader && uploaderEl) {
      const a = document.createElement('a');
      a.href = `/home/?form_type=profile&username=${encodeURIComponent(uploader)}`;
      a.textContent = `Pubblicato da: ${uploader}`;
      a.style.color = 'var(--accent-2)'; a.style.textDecoration = 'none'; a.target = '_blank';
      uploaderEl.innerHTML = ''; uploaderEl.appendChild(a);
    } else if (uploaderEl) uploaderEl.textContent = '';

    const backBtn = el('back-to-feed');
    if (backBtn) backBtn.addEventListener('click', () => {
      try {
        const ref = document.referrer || '';
        if (ref && (ref.includes('/feed') || ref.includes('form_type=feed') || ref.includes('/home/?form_type=feed'))) { window.history.back(); } else { window.location.href = '/home/?form_type=feed'; }
      } catch (e) { window.location.href = '/home/?form_type=feed'; }
    });

    const getDownloadUrl = m => {
      let downloadUrl = m.file || m.link || m.url || m.stored_at || '';
      const isRemote = /^https?:\/\//i.test(downloadUrl) || /^data:/i.test(downloadUrl);
      if(downloadUrl && !isRemote){
        const fname = m.filename || (downloadUrl.split('/').pop()) || downloadUrl;
        const proxyType = (m.type || 'document').toLowerCase();
        return `/show/file?file_type=${encodeURIComponent(proxyType)}&filename=${encodeURIComponent(fname)}`;
      }
      return downloadUrl;
    };

    const t = (media.type || '').toLowerCase();
    const downloadUrl = getDownloadUrl(media);
    const filename = media.filename || (media.stored_at ? media.stored_at.split('/').pop() : (media.file || '-'));

    // display media element
    const setDurationFromElement = (elMedia) => {
      if(!elMedia) return;
      const onLoaded = () => {
        const d = elMedia.duration || 0;
        const disp = formatTime(d);
        const durEl = document.querySelector('[data-field="Duration"] .meta-value');
        if(durEl) durEl.textContent = disp;
      };
      elMedia.addEventListener('loadedmetadata', onLoaded, {once:true});
    };

    if(t==='video' || (filename && filename.match(/\.(mp4|mov|avi|webm)$/i))){
      el('video-box').classList.remove('hidden'); el('video-source').src = downloadUrl || media.link || ''; el('video-player').load(); setDurationFromElement(el('video-player'));
    } else if(t==='audio' || (filename && filename.match(/\.(mp3|wav|m4a|ogg)$/i))){
      el('audio-box').classList.remove('hidden'); el('audio-source').src = downloadUrl || ''; el('audio-player').load(); setDurationFromElement(el('audio-player'));
    } else if(t==='document'){
      el('document-box').classList.remove('hidden'); el('document-viewer').src = downloadUrl || '';
    } else if(t==='concert' || (media.link && /youtube\.com|youtu\.be/i.test(media.link))){
      el('concert-box').classList.remove('hidden'); const vid = extractYouTubeId(media.link || ''); el('concert-iframe').src = vid ? `https://www.youtube.com/embed/${vid}?rel=0` : media.link || '';
    }

    // ---------- DETAILS ----------
    const deriveFormat = () => media.file_format || media.format || (filename && filename.includes('.') ? filename.split('.').pop().toLowerCase() : '-');
    const deriveDuration = () => media.duration_display || (media.duration_seconds ? formatTime(media.duration_seconds) : (media.duration ? formatTime(media.duration) : '-'));

    const details = [
      {k:'Authors', v: safeJoin((media.author_names && media.author_names.length) ? media.author_names : (media.authors || []), '-')},
      {k:'Genre', v: (media.tags && media.tags.length) ? safeJoin(media.tags, '-') : (Array.isArray(media.genres) && media.genres.length ? media.genres.join(', ') : '-')},
      {k:'Composition year', v: media.year || media.date || media.composition_year || '-'},
      {k:'Type', v: media.type || '-'},
      {k:'Filename', v: filename || '-'},
      {k:'Format', v: deriveFormat()},
      {k:'Duration', v: deriveDuration()},
      {k:'Recording date', v: media.recording_date || '-'},
      {k:'Recording location', v: media.recording_location || '-'},
      {k:'Location (stored_at)', v: media.stored_at || '-'},
      {k:'Link', v: media.link || '-'},
      {k:'Pages', v: media.pages || '-'},
      {k:'Description', v: media.description || media.full_description || '-'}
    ];

    const container = el('media-details-content');
    container.innerHTML = '';
    const grid = document.createElement('div'); grid.className='meta-grid';
    details.forEach(d=>{
      const item = document.createElement('div'); item.className='meta-item';
      const title = document.createElement('strong'); title.style.color = 'var(--accent-2)'; title.textContent = d.k;
      const value = document.createElement('div'); value.className='meta-value'; value.style.marginTop='6px'; value.style.color='var(--muted)'; value.textContent = d.v;
      item.appendChild(title); item.appendChild(value); grid.appendChild(item);
    });
    container.appendChild(grid);

    // performers
    if(media.performers && media.performers.length){
      const ptitle = document.createElement('div'); ptitle.className='list-title'; ptitle.textContent='Performers';
      const plist = document.createElement('div'); plist.className='performers-list';
      media.performers.forEach(p=>{
        const it = document.createElement('div'); it.className='performer-item';
        const name = (p.name || p.performer || p.username || p); const inst = (p.instruments && p.instruments.length) ? 'Instruments: '+p.instruments.join(', ') : '';
        it.innerHTML = `<strong>${name}</strong><div style="color:var(--muted)">${inst}</div>`; plist.appendChild(it);
      });
      container.appendChild(ptitle); container.appendChild(plist);
    }

    // sections/subtracks
    if(media.segments && media.segments.length){
      const stitle = document.createElement('div'); stitle.className='list-title'; stitle.textContent='Segments';
      const slist = document.createElement('div'); slist.className='segments-list';
      media.segments.forEach(s=>{
        const it = document.createElement('div'); it.className='segment-item';
        const start = s.start_time || s.start || 0; const end = s.end_time || s.end || 0;
        it.innerHTML = `<strong>${formatTime(start)} â€” ${end ? formatTime(end) : ''}</strong><div style="color:var(--muted)">${s.note_text||s.content||''}</div>`; slist.appendChild(it);
      });
      container.appendChild(stitle); container.appendChild(slist);
    }

    // download (direct)
    if(downloadUrl){
      const dl = document.createElement('a'); dl.id='download-btn'; dl.href = downloadUrl; dl.textContent='Download'; dl.style.marginTop='12px'; dl.style.display='inline-block'; dl.style.marginRight='8px';
      // if same-origin proxy, intercept and force blob download
      dl.addEventListener('click', async (ev) => {
        try {
          if (downloadUrl.startsWith('/show/')) {
            ev.preventDefault();
            const resp = await fetch(downloadUrl, {credentials:'same-origin'});
            if(!resp.ok){ alert('Download fallito'); return; }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename || ''; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          }
        } catch(e){ console.error(e); alert('Errore durante il download'); }
      });
      container.appendChild(dl);
    }

    // OPEN-WITH buttons (same as before)
    // ... keep existing open with logic if needed (omitted for brevity) ...

    // ---------- ADMIN ACTIONS (edit/delete) ----------
    (function createAdminActions(){
      const adminWrap = document.getElementById('admin-actions');
      adminWrap.innerHTML = '';
      if(!adminWrap) return;

      // normalize loggedUser fields
      const currentUser = loggedUser || null;
      const currentLvl = currentUser && (currentUser.lvl !== undefined) ? Number(currentUser.lvl) : null;
      const currentUserId = currentUser && (currentUser.id || currentUser.user_id) ? String(currentUser.id || currentUser.user_id) : null;
      const publisherId = media.user_id ? String(media.user_id) : null;
      const publisherUsername = media.username ? String(media.username) : null;

      const isAdminLevel = [0,1,2].includes(Number(currentLvl));
      const isPublisher = (currentUserId && publisherId && currentUserId === publisherId) || (currentUser && currentUser.username && publisherUsername && currentUser.username === publisherUsername);

      if(!(currentUser && (isAdminLevel || isPublisher))) return;

      const editBtn = document.createElement('button'); editBtn.id='editButton'; editBtn.type='button'; editBtn.textContent='Edit metadata'; editBtn.style.marginRight='8px';
      const deleteBtn = document.createElement('button'); deleteBtn.id='deleteButton'; deleteBtn.type='button'; deleteBtn.textContent='Delete'; deleteBtn.style.background='#c33'; deleteBtn.style.color='#fff';

      adminWrap.appendChild(editBtn); adminWrap.appendChild(deleteBtn);

      // populate & show edit form
      editBtn.addEventListener('click', ()=> {
        // populate fields (allow clearing)
        document.getElementById('edit-title').value = media.title || '';
        document.getElementById('edit-description').value = media.description || '';
        document.getElementById('edit-year').value = media.year || '';
        document.getElementById('edit-duration').value = media.duration || media.duration_seconds || '';
        document.getElementById('edit-recording-date').value = media.recording_date || '';
        document.getElementById('edit-recording-location').value = media.recording_location || '';
        document.getElementById('edit-stored-at').value = media.stored_at || '';
        document.getElementById('edit-link').value = media.link || '';
        document.getElementById('edit-format').value = media.format || media.file_format || '';
        document.getElementById('edit-pages').value = media.pages || '';
        document.getElementById('edit-is-author').checked = !!media.is_author;
        document.getElementById('edit-is-performer').checked = !!media.is_performer;
        document.getElementById('edit-genres').value = Array.isArray(media.tags) ? media.tags.join(', ') : (Array.isArray(media.genres) ? media.genres.join(', ') : '');
        document.getElementById('edit-authors').value = Array.isArray(media.author_names) ? media.author_names.join(', ') : (Array.isArray(media.authors) ? media.authors.join(', ') : '');
        document.getElementById('edit-performers').value = Array.isArray(media.performers) ? media.performers.join(', ') : '';

        showModal('editForm', true);
      });

      document.getElementById('edit-cancel').addEventListener('click', ()=> { showModal('editForm', false); });

      document.getElementById('edit-save').addEventListener('click', async ()=> {
        const btn = document.getElementById('edit-save');
        btn.disabled = true;
        const prevText = btn.textContent;
        btn.textContent = 'Saving...';
        try {
          // build updates: include fields even if empty (to clear them)
          const updates = {};
          const setIfPresent = (key, val) => { updates[key] = (val === '' ? null : val); };

          setIfPresent('title', document.getElementById('edit-title').value.trim());
          setIfPresent('description', document.getElementById('edit-description').value.trim());
          setIfPresent('year', document.getElementById('edit-year').value ? Number(document.getElementById('edit-year').value) : null);
          setIfPresent('duration', document.getElementById('edit-duration').value ? Number(document.getElementById('edit-duration').value) : null);
          setIfPresent('recording_date', document.getElementById('edit-recording-date').value || null);
          setIfPresent('recording_location', document.getElementById('edit-recording-location').value.trim() || null);
          setIfPresent('stored_at', document.getElementById('edit-stored-at').value.trim() || null);
          setIfPresent('link', document.getElementById('edit-link').value.trim() || null);
          setIfPresent('format', document.getElementById('edit-format').value.trim() || null);
          setIfPresent('pages', document.getElementById('edit-pages').value ? Number(document.getElementById('edit-pages').value) : null);

          // proper JS booleans
          updates['is_author'] = document.getElementById('edit-is-author').checked;
          updates['is_performer'] = document.getElementById('edit-is-performer').checked;

          // relations: comma separated -> send as array (server will normalize)
          const genresRaw = document.getElementById('edit-genres').value.trim();
          updates['genres'] = genresRaw === '' ? null : genresRaw.split(',').map(s => s.trim()).filter(Boolean);

          const authorsRaw = document.getElementById('edit-authors').value.trim();
          updates['authors'] = authorsRaw === '' ? null : authorsRaw.split(',').map(s => s.trim()).filter(Boolean);

          const perfRaw = document.getElementById('edit-performers').value.trim();
          updates['performers'] = perfRaw === '' ? null : perfRaw.split(',').map(s => s.trim()).filter(Boolean);
          const resp = await fetch('/show/edit', {
            method: 'POST',
            credentials: 'same-origin',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ media_id: mediaId, updates: updates, type: media.type || null })
          });
          const json = await resp.json().catch(()=>({}));
          if (resp.ok && (json.status === 'OK' || json.status === undefined)) {
            showModal('editForm', false);
            alert('Salvato');
            // reload to reflect persisted changes
            window.location.reload();
          } else {
            alert('Save failed: ' + (json.error_msg || JSON.stringify(json) || resp.status));
          }
        } catch (e) {
          console.error(e);
          alert('Network error during save');
        } finally {
          btn.disabled = false;
          btn.textContent = prevText;
        }
       });
 
      // delete handlers
      deleteBtn.addEventListener('click', ()=> { showModal('confirmationDialog', true); });
      document.getElementById('confirmCancel').addEventListener('click', ()=> { showModal('confirmationDialog', false); });
 
       document.getElementById('confirmDelete').addEventListener('click', async ()=>{
         try {
           const r = await fetch('/show/delete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ media_id: mediaId, type: media.type || null }) });
           const j = await r.json();
           if (r.ok && (j.status === 'OK' || j.status === undefined)) {
             alert('Deleted');
             window.location.href = '/home/?form_type=feed';
           } else {
             alert('Delete failed: ' + (j.error_msg || JSON.stringify(j)));
             showModal('confirmationDialog', false);
           }
         } catch(e){ console.error(e); alert('Network error'); showModal('confirmationDialog', false); }
       });
 
     })();
 
     await loadComments();
 
   } catch(err){
     console.error(err); el('media-title').textContent = "Errore di rete";
   }
 })();
</script>
</body>
</html>